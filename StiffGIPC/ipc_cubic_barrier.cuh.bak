//
// ipc_cubic_barrier.cuh
// GIPC - Cubic Barrier Functions (Ground/Self Collision Kernels)
//
// Cubic barrier implementation based on ppf-contact-solver
// Original log barrier from GIPC.cu refactored to use cubic barrier
//

#pragma once
#ifndef _IPC_CUBIC_BARRIER_H_
#define _IPC_CUBIC_BARRIER_H_

#include <cuda_runtime.h>
#include "gpu_eigen_libs.cuh"
#include "Eigen/Eigen"

//=============================================================================
// Cubic Barrier Functions
// Based on ppf-contact-solver: barrier/cubic.hpp
//
// For distance g and threshold ghat (g < ghat activates barrier):
//   energy(g, ghat)    = -2/3 * (g - ghat)^3 / ghat
//   gradient(g, ghat)  = -2 * (g - ghat)^2 / ghat
//   curvature(g, ghat) = 4 * (1 - g/ghat) = -4 * (g - ghat) / ghat
//=============================================================================

__device__ __host__ inline double cubic_barrier_energy(double g, double ghat)
{
    double y = g - ghat;
    if (y < 0.0) {
        return -2.0 / 3.0 * (y * y * y) / ghat;
    }
    return 0.0;
}

__device__ __host__ inline double cubic_barrier_gradient(double g, double ghat)
{
    double y = g - ghat;
    if (y < 0.0) {
        return -2.0 * y * y / ghat;
    }
    return 0.0;
}

__device__ __host__ inline double cubic_barrier_curvature(double g, double ghat)
{
    double y = g - ghat;
    if (y < 0.0) {
        return 4.0 * (1.0 - g / ghat);
    }
    return 0.0;
}

//=============================================================================
// For I5-based formulation (I5 = (g/ghat)^2):
// Converts to g-space and computes derivatives
//=============================================================================

// Gradient coefficient for I5-based formulation
// Returns dE/dI5 * 2 (the factor that multiplies tmp vector in flatten_pk1)
__device__ __host__ inline double cubic_barrier_I5_gradient_coeff(double I5, double dHat, double Kappa)
{
    // I5 = (g/ghat)^2, so g = ghat * sqrt(I5), ghat = sqrt(dHat)
    double ghat = sqrt(dHat);
    double s = sqrt(I5);  // s = g/ghat
    double g = ghat * s;
    
    if (s >= 1.0) return 0.0;
    
    // dE/dg = -2 * (g - ghat)^2 / ghat * Kappa
    // dE/dI5 = dE/dg * dg/dI5 = dE/dg * ghat / (2 * sqrt(I5))
    //        = -2 * (g - ghat)^2 / ghat * Kappa * ghat / (2 * g)
    //        = -Kappa * (g - ghat)^2 / g
    
    double y = g - ghat;  // y = ghat * (s - 1)
    // The original code uses: flatten_pk1 = tmp * coefficient
    // where tmp.v[8] = s, so coefficient should give dE/dI5 * 2 / s
    // Actually: coefficient such that gradient = tmp * coefficient * PFPx
    
    // For cubic barrier:
    // The coefficient should be: 2 * Kappa * dE_normalized
    // where dE_normalized corresponds to the log barrier's complex expression
    
    // Direct cubic formulation:
    // dE/ds = -2 * Kappa * ghat * (s - 1)^2  (where s = g/ghat)
    // Need to match: flatten_pk1.v[8] = s * coefficient
    // So coefficient = dE/ds / s = -2 * Kappa * ghat * (s - 1)^2 / s
    
    return -2.0 * Kappa * dHat * (s - 1.0) * (s - 1.0) / s;
}

// Hessian eigenvalue for I5-based formulation
__device__ __host__ inline double cubic_barrier_I5_hessian_coeff(double I5, double dHat, double Kappa)
{
    double s = sqrt(I5);  // s = g/ghat
    if (s >= 1.0) return 0.0;
    
    // d^2E/ds^2 = -4 * Kappa * ghat * (s - 1)
    // For eigenvalue decomposition, we need the coefficient for q0 * q0^T
    // lambda0 = d^2E/ds^2 = -4 * Kappa * dHat * (s - 1) / s (normalized)
    
    // The coefficient should be positive when s < 1 (barrier region)
    // Since s - 1 < 0 when s < 1, we get positive value
    return -4.0 * Kappa * dHat * (s - 1.0);
}

//=============================================================================
// Device Helper Functions
//=============================================================================

// Self constraint value calculation
__device__ double _selfConstraintVal_cubic(const double3* _vertexes, const int4& MMCVIDI);

//=============================================================================
// Ground Collision Kernels (Cubic Barrier)
//=============================================================================

__global__ void _GroundCollisionDetect_cubic(const double3*  vertexes,
                                              const uint32_t* surfVertIds,
                                              const double*   g_offset,
                                              const double3*  g_normal,
                                              uint32_t* _environment_collisionPair,
                                              uint32_t* _gpNum,
                                              double    dHat,
                                              int       number);

__global__ void _computeGroundGradientAndHessian_cubic(const double3*  vertexes,
                                                        const double*   g_offset,
                                                        const double3*  g_normal,
                                                        const uint32_t* _environment_collisionPair,
                                                        double3*        gradient,
                                                        uint32_t*       _gpNum,
                                                        Eigen::Matrix3d* triplet_values,
                                                        int*             row_ids,
                                                        int*             col_ids,
                                                        double           dHat,
                                                        double           Kappa,
                                                        int              global_offset,
                                                        int              number);

__global__ void _computeGroundGradient_cubic(const double3*  vertexes,
                                              const double*   g_offset,
                                              const double3*  g_normal,
                                              const uint32_t* _environment_collisionPair,
                                              double3*        gradient,
                                              uint32_t*       _gpNum,
                                              double          dHat,
                                              double          Kappa,
                                              int             number);

__global__ void _computeGroundCloseVal_cubic(const double3*  vertexes,
                                              const double*   g_offset,
                                              const double3*  g_normal,
                                              const uint32_t* _environment_collisionPair,
                                              double          dTol,
                                              uint32_t*       _closeConstraintID,
                                              double*         _closeConstraintVal,
                                              uint32_t*       _close_gpNum,
                                              int             number);

__global__ void _checkGroundCloseVal_cubic(const double3* vertexes,
                                            const double*  g_offset,
                                            const double3* g_normal,
                                            int*           _isChange,
                                            uint32_t*      _closeConstraintID,
                                            double*        _closeConstraintVal,
                                            int            number);

__global__ void _reduct_MGroundDist_cubic(const double3* vertexes,
                                           const double*  g_offset,
                                           const double3* g_normal,
                                           uint32_t*      _environment_collisionPair,
                                           double2*       _queue,
                                           int            number);

__global__ void _checkGroundIntersection_cubic(const double3*  vertexes,
                                                const double*   g_offset,
                                                const double3*  g_normal,
                                                const uint32_t* _environment_collisionPair,
                                                int*            _isIntersect,
                                                int             number);

//=============================================================================
// Barrier Gradient/Hessian Kernels (Cubic Barrier)
//=============================================================================

__global__ void _calBarrierGradientAndHessian_cubic(const double3*   _vertexes,
                                                     const double3*   _rest_vertexes,
                                                     const int4*      _collisionPair,
                                                     double3*         _gradient,
                                                     Eigen::Matrix3d* triplet_values,
                                                     int*             row_ids,
                                                     int*             col_ids,
                                                     uint32_t*        _cpNum,
                                                     int*             matIndex,
                                                     double           dHat,
                                                     double           Kappa,
                                                     int              offset4,
                                                     int              offset3,
                                                     int              offset2,
                                                     int              number);

__global__ void _calBarrierHessian_cubic(const double3*   _vertexes,
                                          const double3*   _rest_vertexes,
                                          const int4*      _collisionPair,
                                          Eigen::Matrix3d* triplet_values,
                                          int*             row_ids,
                                          int*             col_ids,
                                          uint32_t*        _cpNum,
                                          int*             matIndex,
                                          double           dHat,
                                          double           Kappa,
                                          int              offset4,
                                          int              offset3,
                                          int              offset2,
                                          int              number);

__global__ void _calBarrierGradient_cubic(const double3* _vertexes,
                                           const double3* _rest_vertexes,
                                           const int4*    _collisionPair,
                                           double3*       _gradient,
                                           double         dHat,
                                           double         Kappa,
                                           int            number);

//=============================================================================
// Friction Gradient/Hessian Kernels (same as log barrier, friction unaffected)
//=============================================================================

__global__ void _calFrictionHessian_cubic(const double3*          _vertexes,
                                           const double3*          _o_vertexes,
                                           const int4*             _last_collisionPair,
                                           Eigen::Matrix3d*        triplet_values,
                                           int*                    row_ids,
                                           int*                    col_ids,
                                           uint32_t*               _cpNum,
                                           int                     number,
                                           double                  dt,
                                           double2*                distCoord,
                                           __GEIGEN__::Matrix3x2d* tanBasis,
                                           double                  eps2,
                                           double*                 lastH,
                                           double                  coef,
                                           int                     cd_offset4,
                                           int                     cd_offset3,
                                           int                     cd_offset2,
                                           int                     f_offset4,
                                           int                     f_offset3,
                                           int                     f_offset2);

__global__ void _calFrictionHessian_gd_cubic(const double3*   _vertexes,
                                              const double3*   _o_vertexes,
                                              const double3*   _normal,
                                              const uint32_t*  _last_collisionPair_gd,
                                              Eigen::Matrix3d* triplet_values,
                                              int*             row_ids,
                                              int*             col_ids,
                                              int              number,
                                              double           dt,
                                              double           eps2,
                                              double*          lastH,
                                              int              global_offset,
                                              double           coef);

__global__ void _calFrictionGradient_cubic(const double3*          _vertexes,
                                            const double3*          _o_vertexes,
                                            const int4*             _last_collisionPair,
                                            double3*                _gradient,
                                            int                     number,
                                            double                  dt,
                                            double2*                distCoord,
                                            __GEIGEN__::Matrix3x2d* tanBasis,
                                            double                  eps2,
                                            double*                 lastH,
                                            double                  coef);

__global__ void _calFrictionGradient_gd_cubic(const double3*  _vertexes,
                                               const double3*  _o_vertexes,
                                               const double3*  _normal,
                                               const uint32_t* _last_collisionPair_gd,
                                               double3*        _gradient,
                                               int             number,
                                               double          dt,
                                               double          eps2,
                                               double*         lastH,
                                               double          coef);

//=============================================================================
// Self Collision Kernels (Cubic Barrier)
//=============================================================================

__global__ void _calSelfCloseVal_cubic(const double3* _vertexes,
                                        const int4*    _collisionPair,
                                        int4*          _close_collisionPair,
                                        double*        _close_collisionVal,
                                        uint32_t*      _close_cpNum,
                                        double         dTol,
                                        int            number);

__global__ void _checkSelfCloseVal_cubic(const double3* _vertexes,
                                          int*           _isChange,
                                          int4*          _close_collisionPair,
                                          double*        _close_collisionVal,
                                          int            number);

__global__ void _reduct_MSelfDist_cubic(const double3* _vertexes,
                                         int4*          _collisionPairs,
                                         double2*       _queue,
                                         int            number);

__global__ void _computeSelfCloseVal_cubic(const double3*  vertexes,
                                            const double*   g_offset,
                                            const double3*  g_normal,
                                            const uint32_t* _environment_collisionPair,
                                            double          dTol,
                                            uint32_t*       _closeConstraintID,
                                            double*         _closeConstraintVal,
                                            uint32_t*       _close_gpNum,
                                            int             number);

#endif // _IPC_CUBIC_BARRIER_H_

